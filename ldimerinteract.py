

#===================================
#        Chengwen Liu              #
#      liuchw2010@gmail.com        #
#   University of Texas at Austin  #
#===================================


import argparse
import numpy as np
from scipy.optimize import minimize 

def readXYZ(xyz):
  atoms  = np.loadtxt(xyz, usecols=(0,), dtype='str', unpack=True, skiprows=2)
  coords = np.loadtxt(xyz, usecols=(1,2,3), dtype='float', unpack=False, skiprows=2)
  return atoms,coords

def distance(coord1, coord2):
  coord1 = np.array(coord1)
  coord2 = np.array(coord2)
  dist = np.sqrt(np.square(coord1-coord2).sum()) 
  return dist

def rotMatrix(axis, theta):
  axis = np.asarray(axis)
  axis = axis/np.sqrt(np.dot(axis, axis))
  a = np.cos(theta/2.0)
  b, c, d = -axis*np.sin(theta/2.0)
  aa, bb, cc, dd = a*a, b*b, c*c, d*d
  bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d
  rotmat = np.array([[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac)] ,
                     [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab)] ,
                     [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc]] )
  return rotmat

def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('-m1',  dest = 'mono1', required=True)  
  parser.add_argument('-p1',  dest = 'point1', required=True)  
  parser.add_argument('-m2',  dest = 'mono2', required=True)  
  parser.add_argument('-p2',  dest = 'point2', required=True)  
  parser.add_argument('-o',   dest = 'dimer', required=True)
  parser.add_argument('-d',   dest = 'distance', required=True)
  parser.add_argument('-w',   dest = 'weight', default=10)
  args = vars(parser.parse_args())
  mono1 = args["mono1"]
  mono2 = args["mono2"]
  p1 = int(args["point1"])
  p2 = int(args["point2"])
  dimer = args["dimer"]
  dist = float(args["distance"])
  weight = float(args["weight"])
  
  atoms1, coords1 = readXYZ(mono1)
  atoms2, coords2 = readXYZ(mono2)
  coords1 = coords1 - coords1[p1-1]

  def costfunc(params):
    func = 0.0
    coord_opt = np.array(params[:3])
    axis = np.array(params[3:6])
    theta = params[6] 
    rotmat = rotMatrix(axis, theta)
    coords2_t = []
    transvec = coord_opt - coords2[p2-1]
    for n in range(len(coords2)):
      coord2_t = coord_opt + transvec 
      coords2_t.append(coord2_t)
    coords2_t = np.array(coords2_t)
    coords2_r = []
    for n in range(len(coords2_t)):
      coord2_r = np.dot(rotmat, coords2_t[n]) 
      coords2_r.append(coord2_r)
    coords2_r = np.array(coords2_r)
    distsum = 0.0
    for i in range(len(coords1)):
      for j in range(len(coords2_r)):
        if (i!=p1-1) and (j!=p2-1):
          distsum += (1.0/distance(coords1[i], coords2_r[j]))
    func = (np.square(coord_opt).sum()-dist**2) + weight*distsum
    return func
 
  x0 = np.ones(7)
  ret = minimize(costfunc, x0, method='SLSQP', jac=None, bounds=None, options={'disp': True, 'iprint': 1,  'eps': 1.e-8, 'maxiter': 100, 'ftol': 1e-10})
  np.savetxt("p0.txt", ret.x,fmt='%15.10f')

  coord_opt = np.array(ret.x[:3])
  axis = np.array(ret.x[3:6])
  theta = ret.x[6] 

  transvec = (coord_opt) - coords2[int(p2)-1]
  coords2_t = []
  for n in range(len(coords2)):
    coord2_t = coords2[n] + transvec
    coords2_t.append(coord2_t)
  coords2_t = np.array(coords2_t)
  rotmat = rotMatrix(axis, theta)

  coords2_r = []
  for n in range(len(coords2_t)):
    coord2_r = np.dot(rotmat, coords2_t[n]) 
    coords2_r.append(coord2_r)
  coords2_r = np.array(coords2_r)

  transvec = dist*(coords2_r[p2-1])/np.linalg.norm(coords2_r[p2-1]) -coords2_r[p2-1]
  coords2_rt = []
  for n in range(len(coords2_r)):
    coord2_r = coords2_r[n] + transvec
    coords2_rt.append(coord2_r)
  coords2_rt = np.array(coords2_rt)

  with open(dimer, "w") as f:
    f.write("%s\n" %(len(atoms1) + len(atoms2)))
    f.write("Generated by ldimerinteract.py\n")
    for i in range(len(atoms1)):
      f.write("%3s %12.5f%12.5f%12.5f\n"%(atoms1[i], coords1[i][0], coords1[i][1], coords1[i][2]))
    for i in range(len(atoms2)):
      f.write("%3s %12.5f%12.5f%12.5f\n"%(atoms2[i], coords2_rt[i][0], coords2_rt[i][1], coords2_rt[i][2]))
  return

if __name__ == "__main__":
  main()
