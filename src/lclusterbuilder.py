
#===================================
#        Chengwen Liu              #
#      liuchw2010@gmail.com        #
#   University of Texas at Austin  #
#===================================


import argparse
import os,sys
import numpy as np
from random import random


""" 1. put the molecules together to form a reasonable initial cluster;
    2. use random rotation operations to generate bunch of clusters;
    3. low-level QM optimization to further optimize the cluster structures;
    4. select the structures we wanted and do high-level optimization.
"""

# color
RED = '\33[91m'
GREEN = '\33[92m'
YELLOW = '\33[93m'
ENDC = '\033[0m'

def main():  
  if len(sys.argv) == 1:
    sys.exit(RED + "plrease use -h option to see the full usage!" + ENDC) 
  #===>>>
  parser = argparse.ArgumentParser()
  parser.add_argument('-mols', dest = 'molecules', nargs='+', required=True, help="molecules in the cluster")  
  parser.add_argument('-nm', dest = 'nmolecule', required=True, help="number of molecules in the cluster")  
  parser.add_argument('-nc', dest = 'ncluster', required=True, help = "number of cluster structures to be generated")  
  parser.add_argument('-f', dest = 'filename', required=True, help = "prefix filename, for example, Trimer")  
  parser.add_argument('-spn', dest = 'spin', default = 1, help="total spin of the cluster")  
  parser.add_argument('-chg', dest = 'charge', default = 0, help="total chage of the cluster")  
  parser.add_argument('-method', dest = 'method', default = "PBE1PBE", help = "QM method for the initial optimization")  
  parser.add_argument('-grid', dest = 'gridsize', default = 3.0, help="grid size defines the distance between two molecules")  
  args = vars(parser.parse_args())

  molecules = args["molecules"]
  nmol = int(args["nmolecule"])
  ncluster = int(args["ncluster"])
  fname = args["filename"]
  spin = args["spin"]
  method = args["method"]
  charge = args["charge"]
  gridsize = float(args["gridsize"])

  # read atoms and coordinate from xyz file
  def readXYZ(xyz):
    atoms  = np.loadtxt(xyz, usecols=(0,), dtype='str', unpack=True, skiprows=2)
    coords = np.loadtxt(xyz, usecols=(1,2,3), dtype='float', unpack=False, skiprows=2)
    return atoms,coords

  # calculate distance between two atoms 
  def distance(coord1, coord2):
    coord1 = np.array(coord1)
    coord2 = np.array(coord2)
    dist = np.sqrt(np.square(coord1-coord2).sum()) 
    return dist

  # calculate geometric center of a bunch of atoms
  def geomCenter(coords):
    coords = np.array(coords)
    geocent = np.array([coords[:,0].mean(), \
                        coords[:,1].mean(), \
                        coords[:,2].mean()])
    return geocent

  # write XYZ file
  def writeXYZ(atoms, coords, fname):
    with open(fname,"w") as f:
      f.write("%3s\n  generated by lclusterbuilder\n"%len(atoms))
      for atom, coord in zip(atoms, coords):
        f.write("%3s %10.6f%10.6f%10.6f\n"%(atom, coord[0], coord[1], coord[2]))
    return

  # write initial opt file: using Gaussian
  def writeCOM(atoms, coords, fname):
    with open(fname,"w") as f:
      nproc = "%Nproc=8\n" 
      memory = "%Mem=10GB\n"
      keywords = "#p %s/6-31G* Opt(maxcycle=400, Loose) IOP(5/13=1)\n"%method
      #keywords = "#p %s Opt\n"%method
      comment = "Opt job \n"
      chgspin = "  ".join([str(charge), str(spin)]) + "\n"
      f.write(memory + nproc + keywords + "\n" + comment + "\n" + chgspin)
      for atom, coord in zip(atoms, coords):
        f.write("%3s %10.6f%10.6f%10.6f\n"%(atom, coord[0], coord[1], coord[2]))
      f.write("\n")
    return

  # write initial opt file: using Psi4
  def writePSI(atoms, coords, fname): 
    with open(fname,"w") as f:
      f.write("#Generated by lconvert.py for %s job\n\n"%jt)
      chgspin = str(charge) + " " + str(spin)
      f.write("memory %s %s\n\nmolecule  {\n%s\n"%(me[:-2], me[-2:], chgspin))
      for n in range(len(atoms)):
        f.write("%3s   %12.6f%12.6f%12.6f\n"%(atoms[n],float(coords[0][n]),float(coords[1][n]),float(coords[2][n])))
      f.write("\n")
      f.write("units angstrom\nno_reorient\n")
      f.write("symmetry c1\n}\n\n")
      f.write("set {\nscf_type DF\n")
    return
#  GAU_LOOSE

  def translate(sourcecoords, targetcenter):
    geomcenter = geomCenter(sourcecoords)
    transvector = targetcenter - geomcenter 
    targetcoords = sourcecoords + transvector 
    return targetcoords 

  def rotMatrix(axis, theta):
    axis = np.asarray(axis)
    axis = axis/np.sqrt(np.dot(axis, axis))
    a = np.cos(theta/2.0)
    b, c, d = -axis*np.sin(theta/2.0)
    aa, bb, cc, dd = a*a, b*b, c*c, d*d
    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d
    rotmat = np.array([[aa+bb-cc-dd, 2.0*(bc+ad), 2.0*(bd-ac)] ,
                       [2.0*(bc-ad), aa+cc-bb-dd, 2.0*(cd+ab)] ,
                       [2.0*(bd+ac), 2.0*(cd-ab), aa+dd-bb-cc]] )
    return rotmat
  
  if not (len(molecules) == nmol):
    sys.exit(RED + "Error: Number of monomers is different from Nmol !" + ENDC)

  # put molecules together
  clusterGrid = { 1: [ [0.0, 0.0, 0.0],], 
                  2: [ [0.0, 0.0, 0.0], [gridsize, 0.0, 0.0], ], 
                  3: [ [0.0, 0.0, 0.0], [gridsize, 0.0, 0.0], [gridsize/2.0, gridsize*1.732/2.0, 0.0],], 
                  4: [ [0.0, 0.0, 0.0], [gridsize, 0.0, 0.0], [gridsize, gridsize, 0.0], [0.0, gridsize, 0.0], ],
                }
 
  if nmol > 4:
    sys.exit(RED + "Currently only dimer, trimer and tetramer are supported!"   + ENDC)
  
  allatoms = []
  allcoords = []
  natoms = []
  grid = np.array(clusterGrid[nmol])
  for i in range(len(molecules)):
    atoms, coords = readXYZ(molecules[i]) 
    allatoms += list(atoms)
    allcoords += list(translate(coords, grid[i]))  
    natoms.append(len(atoms)) 
  writeXYZ(allatoms, allcoords, "init.xyz")

  # filename
  currindex = 0
  files = os.listdir(os.getcwd())
  for f in files:
    if f.endswith(".com") and (fname in f):
      index = int(f.split(".com")[0].split("_")[-1])
      if index > currindex:
        currindex = index

  # do random rotation
  allatoms, allcoords = readXYZ("init.xyz")
  for j in range(ncluster):
    finalcoords = []
    for i in range(nmol):
      n = natoms[i]
      if i == 0:
        rotmolcoords = allcoords[:n]
        remaincoords = allcoords[n:]
      elif i == (nmol-1):
        rotmolcoords = allcoords[-n:]
        remaincoords = allcoords[:-n]
      else:
        n0 = sum(natoms[:i])
        rotmolcoords = allcoords[n0:n0+n]
        remaincoords = np.array(list(allcoords[:n0]) + list(allcoords[n0+n:]))
      ax = geomCenter(rotmolcoords) - geomCenter(remaincoords)
      theta = np.pi*random()
      rotmat = rotMatrix(ax,theta)
      newcoord = []
      for coord in rotmolcoords: 
        newcoord = np.dot(rotmat, coord) 
        finalcoords.append(newcoord)
    writeCOM(allatoms, finalcoords, fname + "_%03d"%(j+1+currindex) + ".com")
  return

if __name__ == "__main__":
  main()

